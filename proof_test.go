// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pyrios

import (
	"crypto/rand"
	"crypto/sha1"
	"math/big"
	"strings"

	"github.com/golang/glog"
)

// CreateProof proves knowledge of a secret exponent in a cyclic group defined
// by an ElGamal public key.
func (pok *SchnorrProof) CreateProof(secret *big.Int, publicKey *Key) error {
	w, err := rand.Int(rand.Reader, &publicKey.ExponentPrime)
	if err != nil {
		return err
	}

	// The commitment is g^w, and the challenge for the NIZKPOK is
	// generated by sha1(string(g^w)).
	commitment := w.Exp(&publicKey.Generator, w, &publicKey.Prime)
	hash := sha1.Sum([]byte(commitment.String()))

	pok.Commitment = *commitment
	pok.Challenge.SetBytes(hash[:])

	response := big.NewInt(1)
	response.Mul(secret, &pok.Commitment)
	response.Mod(response, &publicKey.ExponentPrime)
	response.Add(response, w)
	response.Mod(response, &publicKey.ExponentPrime)

	pok.Response = *response
	return nil
}

// CreatePartialDecryptionProof produces a proof of knowledge of a value x for
// a DDH tuple (g, g^x, g^R, g^xR).  g^R is the tallied ciphertext alpha value,
// g^xR is the partial decryption, and g^x is the public key of the trustee.
func (proof *ZKProof) CreatePartialDecryptionProof(ciphertext *Ciphertext, decFactor *big.Int, secret *big.Int, publicKey *Key) error {
	// Choose a random value w as the first message.
	w, err := rand.Int(rand.Reader, &publicKey.ExponentPrime)
	if err != nil {
		return err
	}

	// Commit to w with A = g^w, B = alpha^w.
	proof.Commitment.A.Exp(&publicKey.Generator, w, &publicKey.Prime)
	proof.Commitment.B.Exp(&ciphertext.Alpha, w, &publicKey.Prime)

	// Compute the challenge using SHA1
	stringToHash := proof.Commitment.A.String() + "," + proof.Commitment.B.String()
	hashedChall := sha1.Sum([]byte(stringToHash))
	proof.Challenge.SetBytes(hashedChall[:])

	// response = w + challenge * secret
	proof.Response.Mul(&proof.Challenge, secret)
	proof.Response.Add(&proof.Response, w)
	proof.Response.Mod(&proof.Response, &publicKey.ExponentPrime)
	return nil
}

// CreateFakeProof simulates proof creation for a value that's not really encrypted.
// It does this by taking advantage of the degrees of freedom inherent in the NIZKPOK
// for a single value. The only kind of NIZK proof that can be trusted in this system is
// the DisjunctiveZKProof, which is constructed so that exactly one of the values must
// be the encrypted value, and all the other proofs are simulated. And, of course, any
// proof that computes its challenge directly with a hash can be trusted.
func (zkproof *DisjunctiveZKProof) CreateFakeProof(index int64, fakeAnswer int64, c *Ciphertext, pk *Key) error {
	// Choose the challenge and the response at random, and compute the commitment to match.
	chall, err := rand.Int(rand.Reader, &pk.ExponentPrime)
	if err != nil {
		glog.Error("Couldn't choose a random challenge")
		return err
	}

	resp, err := rand.Int(rand.Reader, &pk.ExponentPrime)
	if err != nil {
		glog.Error("Couldn't choose a random response")
		return err
	}

	proof := &(*zkproof)[index]
	proof.Challenge = *chall
	proof.Response = *resp

	// A = (c.Alpha^chall)^{-1} * pk.Generator^resp
	A := &proof.Commitment.A
	A.Exp(&pk.Generator, resp, &pk.Prime)
	temp := new(big.Int)
	temp.Exp(&c.Alpha, chall, &pk.Prime)
	temp.ModInverse(temp, &pk.Prime)
	A.Mul(A, temp)
	A.Mod(A, &pk.Prime)

	// B = pk.PublicValue^resp * (c.Beta/pk.Generator^fakeAnswer)^{-chall}
	B := &proof.Commitment.B
	B.Exp(&pk.PublicValue, resp, &pk.Prime)
	fake := big.NewInt(fakeAnswer)
	temp.Exp(&pk.Generator, fake, &pk.Prime)
	temp.ModInverse(temp, &pk.Prime)
	temp.Mul(temp, &c.Beta)
	temp.Mod(temp, &pk.Prime)
	temp.Exp(temp, chall, &pk.Prime)
	temp.ModInverse(temp, &pk.Prime)
	B.Mul(B, temp)
	B.Mod(B, &pk.Prime)

	return nil
}

// CreateRealProof computes a real NIZKPOK for the answer, which must be the
// value encrypted in the supplied ciphertext. Before this function can be
// called, all the simulated proofs in the DisjunctiveZKProof must be created,
// so that all the commitments are known and can be used to compute the
// challenge value for this proof.
func (zkproof *DisjunctiveZKProof) CreateRealProof(index int64, c *Ciphertext, r *big.Int, pk *Key) error {
	w, err := rand.Int(rand.Reader, &pk.ExponentPrime)
	if err != nil {
		glog.Error("Couldn't choose a random value")
		return err
	}

	// Computing the full challenge requires all the commitments.
	proof := &((*zkproof)[index])
	proof.Commitment.A.Exp(&pk.Generator, w, &pk.Prime)
	proof.Commitment.B.Exp(&pk.PublicValue, w, &pk.Prime)

	challSum := big.NewInt(0)
	var commitVals []string
	for i := range *zkproof {
		p := &((*zkproof)[i])
		// Accumulate the homomorphic product to sum the other challenge values.
		if int64(i) != index {
			challSum.Add(challSum, &p.Challenge)
		}

		commitVals = append(commitVals, p.Commitment.A.String())
		commitVals = append(commitVals, p.Commitment.B.String())
	}

	challSum.Mod(challSum, &pk.ExponentPrime)

	// Create a well-formed challenge.
	stringToHash := strings.Join(commitVals, ",")
	hashedCommits := sha1.Sum([]byte(stringToHash))

	var hashedChall big.Int
	hashedChall.SetBytes(hashedCommits[:])

	// challenge = sha1(A0,B0,...,An,Bn) - sum(all other challenges in the proof)
	proof.Challenge.Sub(&hashedChall, challSum)
	proof.Challenge.Mod(&proof.Challenge, &pk.ExponentPrime)

	// response = w + chall * r
	proof.Response.Mul(&proof.Challenge, r)
	proof.Response.Add(&proof.Response, w)
	proof.Response.Mod(&proof.Response, &pk.ExponentPrime)

	return nil
}

// SplitKey performs an (n,n)-secret sharing of privateKey over addition mod
// publicKey.ExponentPrime.
func SplitKey(privateKey *big.Int, publicKey *Key, n int) ([]Trustee, []big.Int, error) {
	// Choose n-1 random private keys and compute the nth as privateKey -
	// (key_1 + key_2 + ... + key_{n-1}). This computation must be
	// performed in the exponent group of g, which is
	// Z_{Key.ExponentPrime}.
	trustees := make([]Trustee, n)
	keys := make([]big.Int, n)
	sum := big.NewInt(0)
	for i := 0; i < n-1; i++ {
		r, err := rand.Int(rand.Reader, &publicKey.ExponentPrime)
		if err != nil {
			return nil, nil, err
		}

		err = trustees[i].PoK.CreateProof(r, publicKey)
		if err != nil {
			return nil, nil, err
		}

		pub := big.NewInt(1)
		pub.Exp(&publicKey.Generator, r, &publicKey.Prime)
		trustees[i].PublicKey = *publicKey
		trustees[i].PublicKey.PublicValue = *pub
		keys[i] = *r
		sum.Add(sum, r)
		sum.Mod(sum, &publicKey.ExponentPrime)
	}

	// The choice of random private keys in the loop fully determines the
	// final key.
	priv := big.NewInt(0)
	priv.Sub(privateKey, sum)
	priv.Mod(priv, &publicKey.ExponentPrime)
	err := trustees[n-1].PoK.CreateProof(priv, publicKey)
	if err != nil {
		return nil, nil, err
	}

	pub := big.NewInt(1)
	pub.Exp(&publicKey.Generator, priv, &publicKey.Prime)
	trustees[n-1].PublicKey = *publicKey
	trustees[n-1].PublicKey.PublicValue = *pub
	keys[n-1] = *priv
	return trustees, keys, nil
}
