// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pyrios

import (
	"crypto/rand"
	"crypto/sha1"
	"math/big"
	"strings"

	"github.com/golang/glog"
)

// CreateProof proves knowledge of a secret exponent in a cyclic group defined
// by an ElGamal public key.
func (pok *SchnorrProof) CreateProof(secret *big.Int, publicKey *Key) error {
	w, err := rand.Int(rand.Reader, publicKey.ExponentPrime)
	if err != nil {
		return err
	}

	// The commitment is g^w, and the challenge for the NIZKPOK is
	// generated by sha1(string(g^w)).
	pok.Commitment = new(big.Int).Exp(publicKey.Generator, w, publicKey.Prime)
	hash := sha1.Sum([]byte(pok.Commitment.String()))

	pok.Challenge = new(big.Int).SetBytes(hash[:])

	pok.Response = new(big.Int).Mul(secret, pok.Challenge)
	pok.Response.Mod(pok.Response, publicKey.ExponentPrime)
	pok.Response.Add(pok.Response, w)
	pok.Response.Mod(pok.Response, publicKey.ExponentPrime)

	return nil
}

// CreatePartialDecryptionProof produces a proof of knowledge of a value x for
// a DDH tuple (g, g^x, g^R, g^xR).  g^R is the tallied ciphertext alpha value,
// g^xR is the partial decryption, and g^x is the public key of the trustee.
func (proof *ZKProof) CreatePartialDecryptionProof(ciphertext *Ciphertext, decFactor *big.Int, secret *big.Int, publicKey *Key) error {
	// Choose a random value w as the first message.
	w, err := rand.Int(rand.Reader, publicKey.ExponentPrime)
	if err != nil {
		return err
	}

	// Commit to w with A = g^w, B = alpha^w.
	proof.Commitment = &Commit{
		A: new(big.Int).Exp(publicKey.Generator, w, publicKey.Prime),
		B: new(big.Int).Exp(ciphertext.Alpha, w, publicKey.Prime),
	}

	// Compute the challenge using SHA1
	stringToHash := proof.Commitment.A.String() + "," + proof.Commitment.B.String()
	hashedChall := sha1.Sum([]byte(stringToHash))
	proof.Challenge = new(big.Int).SetBytes(hashedChall[:])

	// response = w + challenge * secret
	proof.Response = new(big.Int).Mul(proof.Challenge, secret)
	proof.Response.Add(proof.Response, w)
	proof.Response.Mod(proof.Response, publicKey.ExponentPrime)
	return nil
}

// CreateFakeProof simulates proof creation for a value that's not really encrypted.
// It does this by taking advantage of the degrees of freedom inherent in the NIZKPOK
// for a single value. The only kind of NIZK proof that can be trusted in this system is
// the DisjunctiveZKProof, which is constructed so that exactly one of the values must
// be the encrypted value, and all the other proofs are simulated. And, of course, any
// proof that computes its challenge directly with a hash can be trusted.
func (zkproof *DisjunctiveZKProof) CreateFakeProof(index int64, fakeAnswer int64, c *Ciphertext, pk *Key) error {
	// Choose the challenge and the response at random, and compute the commitment to match.
	chall, err := rand.Int(rand.Reader, pk.ExponentPrime)
	if err != nil {
		glog.Error("Couldn't choose a random challenge")
		return err
	}

	resp, err := rand.Int(rand.Reader, pk.ExponentPrime)
	if err != nil {
		glog.Error("Couldn't choose a random response")
		return err
	}

	proof := &ZKProof{
		Challenge: chall,
		Response: resp,
		Commitment: &Commit{new(big.Int), new(big.Int)},
	}

	// A = (c.Alpha^chall)^{-1} * pk.Generator^resp
	A := proof.Commitment.A
	A.Exp(pk.Generator, resp, pk.Prime)
	temp := new(big.Int).Exp(c.Alpha, chall, pk.Prime)
	temp.ModInverse(temp, pk.Prime)
	A.Mul(A, temp)
	A.Mod(A, pk.Prime)

	// B = pk.PublicValue^resp * (c.Beta/pk.Generator^fakeAnswer)^{-chall}
	B := proof.Commitment.B
	B.Exp(pk.PublicValue, resp, pk.Prime)
	fake := big.NewInt(fakeAnswer)
	temp.Exp(pk.Generator, fake, pk.Prime)
	temp.ModInverse(temp, pk.Prime)
	temp.Mul(temp, c.Beta)
	temp.Mod(temp, pk.Prime)
	temp.Exp(temp, chall, pk.Prime)
	temp.ModInverse(temp, pk.Prime)
	B.Mul(B, temp)
	B.Mod(B, pk.Prime)

	(*zkproof)[index] = proof
	return nil
}

// CreateRealProof computes a real NIZKPOK for the answer, which must be the
// value encrypted in the supplied ciphertext. Before this function can be
// called, all the simulated proofs in the DisjunctiveZKProof must be created,
// so that all the commitments are known and can be used to compute the
// challenge value for this proof.
func (zkproof *DisjunctiveZKProof) CreateRealProof(index int64, c *Ciphertext, r *big.Int, pk *Key) error {
	w, err := rand.Int(rand.Reader, pk.ExponentPrime)
	if err != nil {
		glog.Error("Couldn't choose a random value")
		return err
	}

	// Computing the full challenge requires all the commitments.
	proof := &ZKProof{
		Challenge: new(big.Int),
		Response: new(big.Int),
		Commitment: &Commit{new(big.Int), new(big.Int)},
	}

	(*zkproof)[index] = proof
	proof.Commitment.A.Exp(pk.Generator, w, pk.Prime)
	proof.Commitment.B.Exp(pk.PublicValue, w, pk.Prime)

	challSum := big.NewInt(0)
	var commitVals []string
	for i, p := range *zkproof {
		// Accumulate the homomorphic product to sum the other challenge values.
		if int64(i) != index {
			challSum.Add(challSum, p.Challenge)
		}

		commitVals = append(commitVals, p.Commitment.A.String())
		commitVals = append(commitVals, p.Commitment.B.String())
	}

	challSum.Mod(challSum, pk.ExponentPrime)

	// Create a well-formed challenge.
	stringToHash := strings.Join(commitVals, ",")
	hashedCommits := sha1.Sum([]byte(stringToHash))

	hashedChall := new(big.Int).SetBytes(hashedCommits[:])

	// challenge = sha1(A0,B0,...,An,Bn) - sum(all other challenges in the proof)
	proof.Challenge.Sub(hashedChall, challSum)
	proof.Challenge.Mod(proof.Challenge, pk.ExponentPrime)

	// response = w + chall * r
	proof.Response.Mul(proof.Challenge, r)
	proof.Response.Add(proof.Response, w)
	proof.Response.Mod(proof.Response, pk.ExponentPrime)

	return nil
}

// SplitKey performs an (n,n)-secret sharing of privateKey over addition mod
// publicKey.ExponentPrime.
func SplitKey(privateKey *big.Int, publicKey *Key, n int) ([]*Trustee, []*big.Int, error) {
	// Choose n-1 random private keys and compute the nth as privateKey -
	// (key_1 + key_2 + ... + key_{n-1}). This computation must be
	// performed in the exponent group of g, which is
	// Z_{Key.ExponentPrime}.
	trustees := make([]*Trustee, n)
	keys := make([]*big.Int, n)
	sum := big.NewInt(0)
	var err error
	for i := 0; i < n-1; i++ {
		keys[i], err = rand.Int(rand.Reader, publicKey.ExponentPrime)
		if err != nil {
			return nil, nil, err
		}

		t := new(Trustee)
		t.PoK = new(SchnorrProof)
		err = t.PoK.CreateProof(keys[i], publicKey)
		if err != nil {
			return nil, nil, err
		}

		pub := new(big.Int).Exp(publicKey.Generator, keys[i], publicKey.Prime)
		t.PublicKey = &Key{
			Generator: new(big.Int).Set(publicKey.Generator),
			Prime: new(big.Int).Set(publicKey.Prime),
			ExponentPrime: new(big.Int).Set(publicKey.ExponentPrime),
			PublicValue: pub,
		}

		trustees[i] = t
		sum.Add(sum, keys[i])
		sum.Mod(sum, publicKey.ExponentPrime)
	}

	// The choice of random private keys in the loop fully determines the
	// final key.
	keys[n-1] = new(big.Int).Sub(privateKey, sum)
	keys[n-1].Mod(keys[n-1], publicKey.ExponentPrime)
	tn := new(Trustee)
	tn.PoK = new(SchnorrProof)
	err = tn.PoK.CreateProof(keys[n-1], publicKey)
	if err != nil {
		return nil, nil, err
	}

	pub := new(big.Int).Exp(publicKey.Generator, keys[n-1], publicKey.Prime)
	tn.PublicKey = &Key{
		Generator: new(big.Int).Set(publicKey.Generator),
		Prime: new(big.Int).Set(publicKey.Prime),
		ExponentPrime: new(big.Int).Set(publicKey.ExponentPrime),
		PublicValue: pub,
	}

	trustees[n-1] = tn
	return trustees, keys, nil
}
